use std::{
    env, fs,
    path::{Path, PathBuf},
};

fn main() {
    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR"));
    let templeos_root = manifest_dir.join("third_party/TempleOS");

    let font_path = templeos_root.join("Kernel/FontStd.HC");
    let palette_path = templeos_root.join("Adam/Gr/GrPalette.HC");

    println!("cargo:rerun-if-changed={}", font_path.display());
    println!("cargo:rerun-if-changed={}", palette_path.display());

    let font_bytes =
        fs::read(&font_path).unwrap_or_else(|e| panic!("read {}: {e}", font_path.display()));
    let font_src = String::from_utf8_lossy(&font_bytes);
    let font_sys_std =
        extract_hex_array(font_src.as_ref(), "sys_font_std", 256).expect("parse sys_font_std");

    let palette_bytes =
        fs::read(&palette_path).unwrap_or_else(|e| panic!("read {}: {e}", palette_path.display()));
    let palette_src = String::from_utf8_lossy(&palette_bytes);
    let palette_std_bgr48 = extract_hex_array(palette_src.as_ref(), "gr_palette_std", 16)
        .expect("parse gr_palette_std");
    let palette_std_rgba256 = make_rgba256_from_bgr48_16(&palette_std_bgr48);

    let out_dir = PathBuf::from(env::var("OUT_DIR").expect("OUT_DIR"));
    let out_path = out_dir.join("templeos_assets.rs");
    let rs = format!(
        "{}{}",
        render_rs_font_u64("TEMPLEOS_SYS_FONT_STD_U64", &font_sys_std),
        render_rs_palette_rgba256("TEMPLEOS_GR_PALETTE_STD_RGBA256", &palette_std_rgba256),
    );
    fs::write(&out_path, rs).unwrap_or_else(|e| panic!("write {}: {e}", out_path.display()));
}

fn extract_hex_array(src: &str, symbol: &str, expected_len: usize) -> Result<Vec<u64>, String> {
    let initializer = extract_braced_initializer(src, symbol)?;
    let values = extract_hex_literals(initializer)?;
    if values.len() != expected_len {
        return Err(format!(
            "{symbol}: expected {expected_len} hex literals, got {}",
            values.len()
        ));
    }
    Ok(values)
}

fn extract_braced_initializer<'a>(src: &'a str, symbol: &str) -> Result<&'a str, String> {
    let sym_pos = src
        .find(symbol)
        .ok_or_else(|| format!("missing symbol {symbol}"))?;
    let brace_start_rel = src[sym_pos..]
        .find('{')
        .ok_or_else(|| format!("missing '{{' for {symbol}"))?;
    let brace_start = sym_pos + brace_start_rel;
    let after_brace = &src[brace_start + 1..];
    let end_rel = after_brace
        .find("};")
        .ok_or_else(|| format!("missing '}};' terminator for {symbol}"))?;
    Ok(&after_brace[..end_rel])
}

fn extract_hex_literals(src: &str) -> Result<Vec<u64>, String> {
    let mut values = Vec::new();
    let bytes = src.as_bytes();
    let mut i = 0usize;
    while i + 1 < bytes.len() {
        if bytes[i] == b'0' && bytes[i + 1] == b'x' {
            i += 2;
            let start = i;
            while i < bytes.len() && bytes[i].is_ascii_hexdigit() {
                i += 1;
            }
            if start == i {
                return Err("found 0x without hex digits".to_string());
            }
            let lit = &src[start..i];
            let value = u64::from_str_radix(lit, 16)
                .map_err(|e| format!("parse hex literal 0x{lit}: {e}"))?;
            values.push(value);
            continue;
        }
        i += 1;
    }
    Ok(values)
}

fn make_rgba256_from_bgr48_16(bgr48_16: &[u64]) -> [[u8; 4]; 256] {
    let mut out = [[0u8; 4]; 256];
    for v in out.iter_mut() {
        *v = [0, 0, 0, 0xFF];
    }

    for (i, &bgr48) in bgr48_16.iter().enumerate() {
        out[i] = bgr48_to_rgba8(bgr48);
    }
    out
}

fn bgr48_to_rgba8(bgr48: u64) -> [u8; 4] {
    let b16 = (bgr48 & 0xFFFF) as u16;
    let g16 = ((bgr48 >> 16) & 0xFFFF) as u16;
    let r16 = ((bgr48 >> 32) & 0xFFFF) as u16;
    let r = (r16 >> 8) as u8;
    let g = (g16 >> 8) as u8;
    let b = (b16 >> 8) as u8;
    [r, g, b, 0xFF]
}

fn render_rs_font_u64(name: &str, values: &[u64]) -> String {
    let mut out = String::new();
    out.push_str("// @generated by build.rs (do not edit)\n");
    out.push_str("// Source: third_party/TempleOS/Kernel/FontStd.HC (sys_font_std)\n");
    out.push_str(&format!("pub const {name}: [u64; {}] = [\n", values.len()));
    for (i, v) in values.iter().enumerate() {
        out.push_str(&format!("    0x{v:016X},"));
        if (i + 1) % 4 == 0 {
            out.push('\n');
        } else {
            out.push(' ');
        }
    }
    if values.len() % 4 != 0 {
        out.push('\n');
    }
    out.push_str("];\n\n");
    out
}

fn render_rs_palette_rgba256(name: &str, values: &[[u8; 4]; 256]) -> String {
    let mut out = String::new();
    out.push_str("// @generated by build.rs (do not edit)\n");
    out.push_str("// Source: third_party/TempleOS/Adam/Gr/GrPalette.HC (gr_palette_std)\n");
    out.push_str(&format!("pub const {name}: [[u8; 4]; 256] = [\n"));

    for (i, rgba) in values.iter().enumerate() {
        out.push_str(&format!(
            "    [{}, {}, {}, {}],",
            rgba[0], rgba[1], rgba[2], rgba[3]
        ));
        if (i + 1) % 8 == 0 {
            out.push('\n');
        } else {
            out.push(' ');
        }
    }
    if values.len() % 8 != 0 {
        out.push('\n');
    }

    out.push_str("];\n");
    out
}

#[allow(dead_code)]
fn _assert_exists(path: &Path) {
    if !path.exists() {
        panic!("missing {}", path.display());
    }
}
