# TempleLinux — Research Notes / System Description

Last updated: 2026-02-16

## Abstract

TempleLinux is a Linux-native software stack that tries to recreate the **TempleOS “feel”** (palette, 8×8 font, DolDoc documents, sprite-heavy UI conventions, lightweight apps) **without running the TempleOS kernel**. Instead of virtualizing or emulating the operating system, TempleLinux focuses on **source-level compatibility**:

- TempleOS programs are executed from their **HolyC source** (primarily from a vendored TempleOS tree).
- A small, practical subset of the TempleOS API is implemented and mapped onto a Linux-hosted runtime.
- A full-screen graphical shell (“TempleShell”) renders to a **fixed internal framebuffer** (640×480) and scales it with **nearest-neighbor** to keep pixels crisp.
- Linux remains “real” underneath: the compositor, drivers, packages, browser, editor, etc. are normal Linux programs—optionally living on a separate workspace.

This document describes what TempleLinux **is**, what it **does**, what it **is not**, and how the major subsystems work at a technical level.

---

## 1) What this project is (and isn’t)

### 1.1 What it *is*

TempleLinux is best thought of as a **TempleOS-flavored runtime + UI environment** that runs on Linux:

- **A graphical shell** (`templeshell`) that draws a TempleOS-like screen and hosts a minimal window manager for Temple apps.
- **A HolyC runtime** (`temple-hc`) that can compile and execute a useful subset of HolyC used by real TempleOS demos/apps.
- **A compatibility layer** that implements a subset of TempleOS APIs (graphics, input/messages, docs, filesystem, sound).
- **A shared protocol** (`temple_rt::protocol`) and device layer (`temple_rt::rt::TempleRt`) used by HolyC and Rust apps to draw into a TempleShell-managed framebuffer.
- **A vendored upstream TempleOS source tree** (as a git submodule) used as the canonical “app and asset corpus” (`third_party/TempleOS/`).

The core design principle is: *reuse TempleOS sources and assets as much as possible, and implement only what’s required on the host side to run them deterministically and render them faithfully.*

### 1.2 What it *is not*

TempleLinux is not:

- The TempleOS kernel or boot process.
- A full machine emulator or VM image.
- A binary-compatibility layer for TempleOS binaries/ISOs.
- A “theme pack” that just skins a Linux terminal.

It intentionally avoids OS emulation and focuses on the *developer-facing* surface that TempleOS programs consume: HolyC language + API + rendering conventions.

---

## 2) High-level goals and constraints

The project’s own planning documents describe the intent clearly (see `plan.md`), but the practical constraints matter:

### 2.1 Goals

- **Run TempleOS programs** from `third_party/TempleOS/` as *source* (HolyC) with minimal or no modifications.
- **Pixel-fidelity visuals**:
  - fixed internal resolution (currently 640×480),
  - nearest-neighbor scaling,
  - TempleOS palette conventions (16-color base),
  - TempleOS 8×8 font (exact bits extracted from upstream).
- Provide a **TempleOS-style workflow**:
  - a command prompt shell,
  - help/docs browsing (DolDoc),
  - the PersonalMenu icon “desktop”,
  - small GUI apps/demos that behave like TempleOS.
- Keep Linux usable:
  - launch a browser or open a file via `xdg-open`,
  - optionally switch to a “Linux workspace” automatically when leaving Temple.

### 2.2 Non-goals (at least in the current design)

- Full 1:1 TempleOS API coverage.
- Perfect timing/behavior equivalence for every edge case.
- Running unmodified TempleOS *binaries*.
- Reproducing TempleOS kernel internals (scheduler, drivers, ring0, etc).

---

## 3) Repository layout (what lives where)

At a glance:

- `src/main.rs`  
  The **TempleShell** binary (`templeshell`) entry point. It is the UI host process.

- `src/lib.rs`  
  Library crate entry. Exposes key modules: assets, protocol, rt, sprite, templeos.

- `src/rt.rs` (`temple_rt::rt`)  
  The **device/runtime client** used by apps (HolyC VM and Rust apps) to:
  - connect to TempleShell over IPC,
  - obtain a shared-memory framebuffer,
  - draw pixels/rects/text,
  - present frames and receive input.

- `src/protocol.rs` (`temple_rt::protocol`)  
  The IPC message format and FD-passing helpers (Unix-domain socket protocol).

- `src/assets.rs`  
  CP437 mapping and accessors for embedded TempleOS assets generated by `build.rs`.

- `build.rs`  
  Extracts *real TempleOS* assets from `third_party/TempleOS/` at build time:
  - `Kernel/FontStd.HC` → `sys_font_std`
  - `Adam/Gr/GrPalette.HC` → `gr_palette_std`
  and generates Rust constants in `$OUT_DIR/templeos_assets.rs` which are then included by `src/assets.rs`.

- `src/bin/temple_hc.rs` + `src/bin/temple_hc/**`  
  The **HolyC compiler/runtime** (`temple-hc`):
  - preprocessor (`03_preprocess.rs`),
  - lexer/parser (`mod.rs`),
  - VM (`vm/**`),
  - built-in APIs that emulate TempleOS functions (`vm/builtins/**`).

- `src/bin/temple_demo.rs`, `src/bin/temple_paint.rs`, `src/bin/temple_edit.rs`  
  Small Rust-side Temple apps that speak `TempleRt`.

- `holyc/*.HC`  
  TempleLinux-provided HolyC programs/wrappers, copied into the writable “Temple drive” (`TEMPLE_ROOT`) as needed (on first run and/or on demand). Examples:
  - `LinuxBridge.HC` (host integration UI),
  - `TimeClock.HC` (wrapper around upstream TimeClock),
  - wallpaper demo wrappers to keep “Adam Included” demos alive.

- `tests/gui_smoke.rs`  
  Headless Xvfb-based golden screenshot tests gated behind `TEMPLE_GUI_TESTS=1`.

- `packaging/bin/*`  
  Developer utilities:
  - `templelinux-session` (sway-based session),
  - GUI smoke scripts (X11/Wayland),
  - screenshot capture + upload.

- `third_party/TempleOS/`  
  Upstream TempleOS source tree (git submodule).

---

## 4) User-facing experience: what you can do with it

### 4.1 Running TempleShell

`templeshell` is the primary entry point. It creates:

- a window (Wayland or X11 via winit),
- a fixed internal framebuffer (640×480),
- a command prompt + status bar,
- an internal IPC server used by Temple apps.

In interactive use, TempleShell is typically fullscreen, but it supports `--no-fullscreen` (used heavily in test harnesses).

### 4.2 The TempleShell command prompt

TempleShell includes a lightweight, TempleOS-ish command interpreter. Key built-in commands include (see `src/templeshell/02_shell.rs`):

- Filesystem-like commands on the **Temple drive**:
  - `pwd`, `cd`, `ls`, `cat`, `cp`, `mv`, `rm`, `mkdir`, `touch`
  - text tools: `grep`, `find`, `head`, `tail`, `wc`
  - pagers: `more`, `less`

- Environment and state:
  - `env` (show variables)
  - `set k=v` (persisted per-user variables)
  - `clip` (host clipboard get/set)

- UI surfaces:
  - `apps` / `launcher` (UI launcher)
  - `files` / `fm` (file browser UI)
  - `menu` (TempleOS PersonalMenu icon “desktop”)

- Running programs:
  - `tapp ...` (launch a Temple app / TempleOS program)
  - `hc` / `holyc` (alias to `tapp hc ...`)
  - `edit` (launch `temple-edit`)

- Linux integration:
  - `open <path>` (spawn `xdg-open`)
  - `browse <url>` (spawn `xdg-open`)
  - `run <cmd>` (spawn a Linux command)
  - `ws <target>` (workspace switching via sway IPC)

- Diagnostics:
  - `screenshot` / `shot` (save a PNG from the internal framebuffer)

These commands give TempleShell a “mini OS” feel while remaining a normal Linux process.

### 4.3 Temple apps and the internal window manager

TempleShell can host multiple “Temple apps” at once. Apps are not Linux windows—TempleShell draws them into **internal windows** inside the 640×480 framebuffer.

Capabilities include:

- multiple app windows,
- focus and z-order,
- click-to-focus,
- drag title bar to move,
- close windows (UI close button or hotkeys),
- wallpaper apps: a special app kind that draws behind the terminal and windows.

Examples of apps:

- `tapp demo` (Rust demo app: rect + input)
- `tapp paint` (Rust paint app)
- `tapp edit <file>` (Rust editor)
- `tapp hc <file>` (HolyC runner)
- wrappers like `tapp linuxbridge`, `tapp timeclock`, `tapp wallpaperfish`
- upstream TempleOS demos/games, run from source (`tapp hc ::/Demo/...`)

---

## 5) Filesystem model: Temple drive vs TempleOS tree

TempleLinux distinguishes between two major “roots”:

### 5.1 `TEMPLE_ROOT` (writable)

This is the writable Temple drive root. Default is:

- `~/.templelinux` (created by TempleShell), unless `TEMPLE_ROOT` is set.

TempleShell creates and manages key directories under it:

- `Home/` (user files)
- `Doc/` (TempleLinux docs / overlays)
- `Cfg/` (config such as history, variables, autostart)
- `Apps/` (TempleLinux-provided HolyC apps like LinuxBridge)

Notable files:

- `Cfg/History.txt` — shell history
- `Cfg/Vars.txt` — key=value variables
- `Cfg/AutoStart.tl` — executed at startup (line-by-line)
- `Cfg/LinuxRunAllow.txt` — allowlist for `LinuxRun()` (HolyC built-in)

### 5.2 `TEMPLEOS_ROOT` (read-only)

This points to a TempleOS source tree, typically the vendored submodule:

- `third_party/TempleOS/`

Both TempleShell and `temple-hc` try to discover it automatically by searching parent directories for `third_party/TempleOS/Kernel/FontStd.HC`, or using:

- `TEMPLEOS_ROOT` env var,
- a system path like `/usr/share/templelinux/TempleOS` (packaging scenario).

### 5.3 Path conventions

TempleLinux supports TempleOS-style “drive specs” in several places:

- `::/Foo/Bar.HC` → resolves into the TempleOS tree (`TEMPLEOS_ROOT/Foo/Bar.HC`)
- `/Home/…` → resolves into the writable Temple drive (`TEMPLE_ROOT/Home/...`)

This split is important:

- Vendored TempleOS sources are treated as canonical and should stay clean.
- User state and TempleLinux-specific code live under `TEMPLE_ROOT`.

---

## 6) Core architecture: processes, IPC, and shared memory

### 6.1 Process model

TempleLinux is intentionally **multi-process**:

- `templeshell` is the host UI process and IPC server.
- Temple apps are separate processes:
  - Rust apps: `temple-demo`, `temple-paint`, `temple-edit`
  - HolyC apps: `temple-hc` (runs HolyC source files)

This mirrors a simple “window server + clients” design:

```
            +-------------------------------+
            |           templeshell         |
            |  - renders 640x480 framebuffer|
            |  - window manager (internal)  |
            |  - IPC server + app registry  |
            +---------------+---------------+
                            |
                    Unix domain socket
                    + shared memory (memfd)
                            |
      +---------------------+----------------------+
      |                     |                      |
 +----v-----+        +------v------+        +------v------+
 |temple-hc |        |temple-demo  |        |temple-edit  |
 |(HolyC VM)|        |(Rust app)   |        |(Rust editor)|
 +----------+        +-------------+        +-------------+
```

### 6.2 IPC transport: Unix-domain sockets + FD passing

The IPC protocol lives in `src/protocol.rs` and is designed to be:

- small and deterministic,
- easy to use from Rust,
- capable of passing a file descriptor for shared memory.

Message framing:

- fixed-size 16-byte header (`Msg::LEN == 16`)
- magic bytes `TPRT`, version `0`
- fields: `kind: u16`, `a: u32`, `b: u32`

Some key message kinds:

- `MSG_HELLO` / `MSG_HELLO_ACK` — handshake
- `MSG_PRESENT` / `MSG_PRESENT_ACK` — frame presentation + synchronization
- `MSG_KEY`, `MSG_MOUSE_MOVE`, `MSG_MOUSE_BUTTON`, `MSG_MOUSE_WHEEL`, `MSG_MOUSE_ENTER/LEAVE` — input
- `MSG_CLIPBOARD_SET` — app → host clipboard
- `MSG_SND`, `MSG_MUTE` — sound control
- `MSG_PALETTE_COLOR_SET` — dynamic palette updates
- `MSG_SETTINGS_PUSH/POP` — settings stack (palette stack) behavior
- `MSG_SHUTDOWN` — host → app shutdown request

### 6.3 Shared framebuffer

Apps do not stream pixels over IPC. Instead:

1. App connects to the Unix socket at `TEMPLE_SOCK`.
2. App sends `HELLO`.
3. TempleShell responds with `HELLO_ACK(width, height)` and includes a **memfd file descriptor**.
4. App `mmap()`s that fd into its process and draws into it.

This makes “drawing” essentially a shared-memory write into an 8bpp index buffer.

### 6.4 Present synchronization (“present ack”)

The `present()` call is conceptually:

- app writes pixels into shared memory
- app sends `MSG_PRESENT(seq)` to the host

TempleShell:

- receives `MSG_PRESENT(seq)` from that app
- schedules a redraw and eventually sends `MSG_PRESENT_ACK(seq)`

The client-side runtime (`TempleRt`) can optionally wait for the ack for determinism:

- env `TEMPLE_SYNC_PRESENT=1` makes `TempleRt::present()` block until the ack arrives (with a timeout controlled by `TEMPLE_SYNC_PRESENT_TIMEOUT_MS`).

This mechanism is crucial for:

- deterministic GUI golden tests,
- headless screenshot capture.

---

## 7) Rendering model: 640×480 indexed pixels → GPU blit

### 7.1 Internal representation

TempleShell’s internal framebuffer is:

- fixed size: `INTERNAL_W=640`, `INTERNAL_H=480`
- stored as `Vec<u8>` indices (palette indices)
- converted every frame into an RGBA buffer for GPU upload.

The palette is a 256-entry RGBA table, with the first 16 entries derived from TempleOS’ standard palette (`gr_palette_std`). Palette entries can be edited dynamically by apps via `MSG_PALETTE_COLOR_SET`.

### 7.2 Pixel-perfect scaling

TempleShell never asks the compositor to scale the content with linear filtering. Instead:

- it renders its own window at the compositor-provided size,
- and draws a full-screen quad sampling from the 640×480 texture using a **nearest-neighbor sampler** (`wgpu::FilterMode::Nearest`).

This preserves the “hard pixel” look of TempleOS.

### 7.3 Letterboxing and coordinate mapping

Because the output window may not match the internal 4:3 aspect ratio, TempleShell computes a letterbox transform:

- find a scale that fits 640×480 into the window,
- center it,
- map mouse coordinates from output → internal coordinates by undoing offset and scale.

All UI logic (terminal cells, window manager, doc viewer hit testing) happens in internal pixel coordinates and is independent of the actual monitor resolution.

---

## 8) Fonts, palette, and CP437

TempleOS uses:

- an 8×8 bitmap font (`sys_font_std`)
- a 16-color palette with “TempleOS-typical” color names
- lots of CP437 bytes in source/doc content (box drawing characters, symbols)

TempleLinux treats these as core compatibility assets:

### 8.1 Exact font extraction

`build.rs` parses `third_party/TempleOS/Kernel/FontStd.HC` and extracts the `sys_font_std` glyph data, embedding it as `TEMPLEOS_SYS_FONT_STD_U64`.

Text rendering in `TempleRt` uses these glyph rows directly; there’s no antialiasing or system font dependency.

### 8.2 Palette extraction

`build.rs` parses `third_party/TempleOS/Adam/Gr/GrPalette.HC` and extracts `gr_palette_std`, embedding it as `TEMPLEOS_GR_PALETTE_STD_RGBA256`.

### 8.3 CP437 encoding/decoding

`src/assets.rs` implements:

- CP437 → Unicode mapping (for rendering and display)
- Unicode → CP437 mapping (to support drawing characters that TempleOS expects)

The core principle: treat TempleOS text content as fundamentally byte-oriented and do not assume UTF-8.

---

## 9) HolyC execution: `temple-hc`

### 9.1 The main idea

TempleLinux’s HolyC strategy is **source compatibility**, not “run TempleOS binaries.”

`temple-hc`:

- reads a `.HC`/`.HH` source file (often from `::/` TempleOS paths),
- preprocesses includes and macros,
- parses into an AST-like program representation,
- executes it in a VM that calls into TempleLinux built-ins.

This is a practical subset intended to run real upstream programs.

### 9.2 Preprocessing and TempleOS file conventions

TempleOS sources include patterns that differ from typical C toolchains:

- `::/` paths for includes and assets
- files containing a NUL byte and then “binary tail” records used by DolDoc `$IB` sprites

TempleLinux’s preprocessor (`src/bin/temple_hc/03_preprocess.rs`) handles:

- `#include` resolution (including auto-extension probing like `.HC`, `.HH`, `.H`)
- file discovery for `TEMPLEOS_ROOT`
- extraction of “bin tail” records after the NUL terminator into a per-file `bins_by_file` map

This `bins_by_file` map is later used to resolve `$IB` sprite data when rendering DolDoc docs.

### 9.3 VM structure and built-ins

The VM (`src/bin/temple_hc/vm/**`) maintains:

- a `TempleRt` connection (graphics/input/present),
- an environment with TempleOS-like global objects (`Fs`, `gr`, `text`, etc.),
- message queues and modifier state,
- a heap for arrays/objects,
- deterministic controls for tests (seed and fixed timestamp).

TempleOS API surface is implemented primarily as built-ins:

- graphics: `vm/builtins/gfx.rs` (`GrPlot`, `GrLine`, sprites, etc.)
- input/ui/sound: `vm/builtins/ui_input_sound.rs` (`GetChar`, `ScanMsg`, `Snd`, …)
- docs/fs/settings: `vm/builtins/doc_fs_settings.rs` (`DocClear`, file ops, …)
- linux integration: `vm/builtins/linux.rs` (`LinuxBrowse`, `LinuxOpen`, `LinuxRun`, …)

Where TempleOS APIs have “extra dimensions” (e.g., `GrLine3`), TempleLinux frequently accepts the signature but ignores fields that aren’t needed for the 2D framebuffer.

### 9.4 Determinism knobs

Some upstream demos depend on time and randomness. The VM supports:

- `TEMPLE_HC_SEED=<u64>` to force a deterministic RNG seed,
- `TEMPLE_HC_FIXED_TS=<f64>` to force a deterministic timestamp.

The screenshot/test tooling uses these to keep golden PNGs stable.

---

## 10) TempleOS API compatibility: what exists today

The authoritative map is `TEMPLEOS_API.md`. At a high level, the compatibility layer provides:

### 10.1 Graphics

- low-level pixel ops (`GrPlot`)
- lines and rectangles (`GrLine`, `GrRect`, `GrBorder`, etc.)
- circles/ellipses (approximations)
- palette updates (`GrPaletteColorSet`)
- sprite rendering for DolDoc and sprite demos

Graphics are palette-indexed (8bpp indices), matching TempleOS’ conventions.

### 10.2 Input and message loop

TempleOS has a message-driven UI model (MSG_* constants, `GetMsg`, `ScanMsg`). TempleLinux implements a subset by:

- converting IPC input events into TempleOS-like messages
- maintaining a message queue in the HolyC VM
- supporting menu overlays (`MenuPush`/`MenuPop`) used by real apps.

### 10.3 Filesystem

TempleOS apps expect `Cd`, directory listing, basic file IO. TempleLinux supports a subset with path rules:

- `/Home/...` resolves into `TEMPLE_ROOT`
- `::/...` resolves into `TEMPLEOS_ROOT`

The split keeps vendored sources read-only and user data writable.

### 10.4 Sound

TempleOS uses “Ona” note values (`Snd(ona)`). TempleShell implements a simple tone generator using `cpal`:

- app sends `MSG_SND` / `MSG_MUTE`
- TempleShell audio thread converts Ona → frequency and plays a sine tone.

### 10.5 Settings stack

Some TempleOS programs “push” and “pop” graphics settings (notably palette changes). TempleShell maintains a palette stack:

- `MSG_SETTINGS_PUSH` pushes current palette,
- `MSG_SETTINGS_POP` restores previous palette.

This allows demos that temporarily change palette to behave more like TempleOS.

---

## 11) Documents: DolDoc rendering and sprite embedding

TempleOS’ help system is DolDoc (`.DD`) and contains a mix of:

- rich text controls via `$...$` commands,
- links,
- sprites (`$SP...$`) that refer to binary resources stored *inside* the `.DD` file.

TempleLinux implements a practical DolDoc viewer inside TempleShell:

### 11.1 Doc sources

`help <topic>` looks in multiple places:

- TempleLinux doc overlays in `TEMPLE_ROOT/Doc/` (e.g., `.TD`, `.txt`)
- vendored TempleOS docs (`TEMPLEOS_ROOT/Doc/*.DD`)
- direct specs like `help ::/PersonalMenu.DD` or `help FF:::/PersonalMenu.DD,X-Caliber` (TempleOS-style spec forms used in tests and debugging)

### 11.2 Rendering model

Doc rendering in TempleShell converts doc content into terminal “cells”:

- each cell is `(ch, fg, bg)`
- the viewer supports scrolling
- links are tracked with ranges (line/col spans)

### 11.3 Supported DolDoc features (subset)

The DolDoc parser in `src/templeshell/02_shell.rs` supports a subset of commands that show up heavily in upstream docs:

- text and color changes (`$FG`, `$BG`, `$BK`, `$IV`, `$HL`, `$UL`, etc.)
- link commands (`$LK` with quoted args and attributes)
- centered text (`$TX` with `CX` flag)
- HTML blocks (`$HC`) rendered as a placeholder, optionally exposing the first URL as a clickable “browse” action
- song blocks (`$SO`) rendered as text or action placeholders
- sprites (`$SP` with `BI=<n>`) rendered by decoding the `.DD` bin tail record `n`

The parser is intentionally conservative and robust against minor corruption found in some vendored files (e.g., off-by-one bin tail truncation).

### 11.4 Sprite rendering

Sprites are drawn after the doc’s text pass:

- doc parsing records sprite anchors and bounding boxes in cell coordinates
- the render loop resolves sprite binary data (`BI=<n>`) from the doc’s bin map
- `temple_rt::sprite::sprite_render()` draws sprite elements into the framebuffer

This is essential for TempleOS UIs like:

- `HelpIndex.DD`
- `PersonalMenu.DD` icon desktop

Sprites may contain bitmaps and/or meshes, and TempleLinux includes logic to decode these formats from TempleOS’ stored representation.

---

## 12) Host integration: “LinuxBridge” and controlled escape hatches

TempleLinux intentionally allows limited interaction with the host OS while keeping a TempleOS-like UI.

### 12.1 `open` / `browse` from TempleShell

TempleShell’s shell provides:

- `open <path>` → `xdg-open <file>`
- `browse <url>` → `xdg-open <url>`

These spawn host processes and can optionally switch to a host workspace (see below).

### 12.2 HolyC-side Linux built-ins

The HolyC VM implements `LinuxBrowse`, `LinuxOpen`, and `LinuxRun` (see `src/bin/temple_hc/vm/builtins/linux.rs`).

- `LinuxBrowse("https://...")` spawns `xdg-open` on a URL.
- `LinuxOpen("/Home/...")` resolves Temple paths into host paths, then spawns `xdg-open`.
- `LinuxRun("cmd ...")` spawns an arbitrary program **only if allowed**.

### 12.3 `LinuxRun` is deny-by-default

Running host commands from HolyC is a security boundary. TempleLinux makes `LinuxRun` **disabled unless explicitly enabled** via:

- env `TEMPLE_LINUX_RUN_ALLOW="chrome,firefox,foot"` (comma/whitespace separated), or
- `TEMPLE_ROOT/Cfg/LinuxRunAllow.txt` (one allowed program per line).

This keeps accidental or malicious upstream HolyC from turning into an unrestricted shell escape.

### 12.4 Workspace switching (sway)

TempleLinux includes sway-specific workspace behavior:

- `packaging/bin/templelinux-session` generates a sway config with:
  - workspace 1 = TempleShell fullscreen
  - workspace 2 = Linux apps
  - hotkeys Super+1 / Super+2

The HolyC VM also supports “auto switch to Linux workspace after launching a host app”:

- if `TEMPLE_AUTO_LINUX_WS=1`, `LinuxBrowse/Open/Run` calls attempt to run `swaymsg workspace number <n>`.
- `TEMPLE_WS_LINUX` selects which workspace number (default `2`).

This is a pragmatic “Back to Temple” workflow: TempleShell is always one keypress away.

---

## 13) Testing strategy: keeping compatibility from regressing

TempleLinux uses two tiers of smoke testing:

### 13.1 Protocol-level tests (`cargo test -q`)

Many tests execute HolyC programs in a “headless” mode using a fake/controlled runtime and assert:

- compilation success,
- expected text output,
- expected present behavior.

The goal is to validate the HolyC runtime + API layer without requiring a real display.

### 13.2 GUI golden tests (Xvfb)

`tests/gui_smoke.rs` runs TempleShell under Xvfb and captures deterministic PNGs, then verifies SHA-256 hashes.

These tests are gated behind:

- `TEMPLE_GUI_TESTS=1`

They validate that the *actual rendered output* of key UI surfaces stays stable:

- TempleShell initial screen
- file browser view
- DolDoc views
- LinuxBridge app
- editor UI
- menu demo, multi-window layouts, etc.

This is particularly important because pixel-compatibility is a primary objective.

### 13.3 Screenshot gallery tooling

`packaging/bin/templelinux-publish-screenshots` can:

- build binaries,
- run a curated set of demos/apps under Xvfb,
- dump PNGs plus a generated `index.html` gallery,
- upload via `wtf-upload`.

In addition, this repository now stores a “known-good” set of screenshots under `docs/screenshots/` so that GitHub can render them in `README.md`.

---

## 14) Limitations and open problems (research perspective)

Because TempleLinux is intentionally not a full OS emulator, some limitations are structural:

### 14.1 HolyC and API coverage is partial

TempleLinux’s HolyC parser/VM and built-in APIs focus on what upstream demos actually need. Many TempleOS APIs and language constructs may be missing or approximated.

This is an explicit “coverage grows with real programs” approach.

### 14.2 Timing and “Adam Included” semantics

Some TempleOS demos assume a persistent kernel/task environment (e.g., “Adam Included” behavior). TempleLinux often wraps these demos in small HolyC adapters (`holyc/WallPaperFish.HC`, `holyc/WallPaperCtrl.HC`) that keep them alive in a loop.

Fully reproducing TempleOS task/include lifetime semantics would require deeper VM/runtime work.

### 14.3 Platform specificity (Wayland + sway)

TempleShell is a normal Linux GUI program and can run under:

- Wayland
- X11 (including Xvfb for tests)

However, some “session workflow” features currently target `sway` for workspace switching via `swaymsg`. Porting those behaviors to other compositors would require additional adapters.

### 14.4 Security boundary is “best effort”

TempleLinux can run arbitrary upstream HolyC. Even with deny-by-default host escapes, it still:

- reads files you point it at,
- can write within `TEMPLE_ROOT`,
- can open URLs/files via `xdg-open` if the user triggers it.

This is a research/enthusiast project; threat modeling for hostile inputs is not the primary design driver.

---

## 15) Practical “what does it do?” summary

If you describe TempleLinux in one paragraph:

> TempleLinux is a TempleOS-like environment implemented as a Linux GUI program (“TempleShell”) plus a HolyC runtime (“temple-hc”). It runs TempleOS applications from their source code (usually from a vendored TempleOS tree) by providing a compatibility subset of TempleOS APIs (graphics, input/messages, docs, filesystem, sound). Apps draw into shared-memory framebuffers managed by TempleShell, which renders everything at a fixed 640×480 internal resolution using the real TempleOS font and palette assets and scales it pixel-perfectly. It also provides optional bridges to the host OS (open URLs/files, run allowlisted commands, workspace switching) so the “Temple experience” can coexist with normal Linux applications.

---

## Appendix A) Key binaries and their roles

- `templeshell`  
  Host process: UI + window manager + IPC server + docs viewer + launcher.

- `temple-hc`  
  HolyC compiler/VM. Connects to TempleShell via `TEMPLE_SOCK` and runs `.HC` programs.

- `temple-demo`  
  Simple Rust demo app for input/graphics/clipboard.

- `temple-paint`  
  Simple Rust paint app.

- `temple-edit`  
  Simple Rust editor, with compile-check/run integration with `temple-hc`.

---

## Appendix B) Important environment variables

### Runtime / paths

- `TEMPLE_ROOT` — writable “Temple drive” root (`~/.templelinux` by default)
- `TEMPLEOS_ROOT` — path to the TempleOS source tree (auto-discovered if possible)
- `TEMPLE_SOCK` — Unix socket path used for TempleShell ↔ app IPC

### Determinism / tests

- `TEMPLE_SYNC_PRESENT=1` — app `present()` waits for host ack
- `TEMPLE_SYNC_PRESENT_TIMEOUT_MS=<ms>` — present-ack timeout
- `TEMPLE_GUI_TESTS=1` — enable GUI golden tests
- `TEMPLE_HC_SEED=<u64>` — deterministic HolyC RNG seed
- `TEMPLE_HC_FIXED_TS=<f64>` — deterministic HolyC timestamp

### Host integration

- `TEMPLE_LINUX_RUN_ALLOW=...` — allowlist for HolyC `LinuxRun()`
- `TEMPLE_AUTO_LINUX_WS=1` — auto switch to Linux workspace after launching host apps
- `TEMPLE_WS_LINUX=<n>` — which sway workspace number is “Linux” (default 2)
- `SWAYSOCK` — required for sway IPC-based workspace switching

---

## Appendix C) How to run and validate

Build:

```bash
cargo build
```

Run TempleShell:

```bash
cargo run --bin templeshell
```

In TempleShell try:

- `menu`
- `apps`
- `tapp demo`
- `tapp hc ::/Demo/Graphics/NetOfDots.HC` (requires `TEMPLEOS_ROOT` to be discoverable)

Run tests:

```bash
cargo test -q
TEMPLE_GUI_TESTS=1 cargo test -q --test gui_smoke
```

---

## Appendix D) Why this approach is interesting (research framing)

TempleLinux is a concrete example of a “**source-compatibility platform**” for an unusual, tightly-integrated OS ecosystem:

- It treats an upstream OS source tree as the **canonical application corpus**.
- It reimplements only the practical surface area needed for representative programs.
- It prioritizes **visual fidelity** (assets + pixel scaling) as a first-class compatibility metric.
- It uses a deliberately small IPC protocol and shared memory to keep rendering fast and deterministic.

The result is not “TempleOS on Linux” in the virtualization sense; it is closer to building a “TempleOS userland personality” hosted by Linux, with a custom UI shell and a language/runtime adapter.
